package org.sevenstar.monitor.database.filter.jdbc;

import java.sql.CallableStatement;
import java.sql.ParameterMetaData;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.sevenstar.monitor.database.context.SQLContext;
import org.sevenstar.monitor.database.toolkit.jdbc.filter.ICallableStatementFilter;

public class CallableStatementFilterImpl implements ICallableStatementFilter {

	private static Log LOG = LogFactory.getLog(CallableStatementFilterImpl.class);

	private static List stringList;

	private static List numberList;

	private String sql;

	static {
		stringList = new ArrayList();
		stringList.add(String.class.getName());
		stringList.add(java.lang.Character.class.getName());
		numberList = new ArrayList();
		numberList.add(Long.class.getName());
		numberList.add(Integer.class.getName());
		numberList.add(Double.class.getName());
		numberList.add(Float.class.getName());
	}

	private List paramList;

	public List getParamList() {
		return paramList;
	}

	public void setParamList(List paramList) {
		this.paramList = paramList;
	}

	private String dateToStringCommon(Date date) {
		SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
		try {
			return df.format(date);
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}

	private String prepareSql(CallableStatement callableStatement, String sql) {
		try {
			ParameterMetaData metaData = callableStatement.getParameterMetaData();
			for (int i = 0; i < metaData.getParameterCount(); i++) {
				if(i >= paramList.size()){
					sql = sql.replaceAll("\\?", "null");
					continue;
				}
				Object paramValue = paramList.get(i);
				if (paramValue == null && sql.indexOf("?") != -1) {
					sql = sql.replaceFirst("\\?", "null");
				} else {
					try {
						if (stringList
								.contains(paramValue.getClass().getName())
								&& sql.indexOf("?") != -1) {
							sql = sql.replaceFirst("\\?", "'" + paramValue
									+ "'");
						} else if (numberList.contains(paramValue
								.getClass().getName())
								&& sql.indexOf("?") != -1) {
							sql = sql.replaceFirst("\\?", "" + paramValue);
						} else if ((Date.class.getName()).equals(paramValue
								.getClass().getName())
								&& sql.indexOf("?") != -1) {
							sql = sql.replaceFirst("\\?", "to_date('"
									+ dateToStringCommon((Date) paramValue)
									+ "','yyyy-mm-dd HH:MM:SS')");
						} else if (sql.indexOf("?") != -1) {
							sql = sql.replaceFirst("\\?", "'UNKNOWTYPE'");
						}
					} catch (Exception e) {
						sql = sql.replaceFirst("\\?", "'UNKNOWTYPE'");
						LOG.error(e);
					}
				}
			}
			return sql;
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}

	public boolean execute(CallableStatement callableStatement)
			throws SQLException {
		SQLContext.push(prepareSql(callableStatement, this.getSql()));
 		return callableStatement.execute();
	}

	public boolean execute(CallableStatement callableStatement, String sql)
			throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.execute(sql);
	}

	public boolean execute(CallableStatement callableStatement, String sql,
			int autoGeneratedKeys) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.execute(sql, autoGeneratedKeys);
	}

	public boolean execute(CallableStatement callableStatement, String sql,
			int[] columnIndexes) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.execute(sql, columnIndexes);
	}

	public boolean execute(CallableStatement callableStatement, String sql,
			String[] columnNames) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.execute(sql, columnNames);
	}

	public ResultSet executeQuery(CallableStatement callableStatement)
			throws SQLException {
		SQLContext.push(prepareSql(callableStatement, this.getSql()));
		return callableStatement.executeQuery();
	}

	public ResultSet executeQuery(CallableStatement callableStatement,
			String sql) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.executeQuery(sql);
	}

	public int executeUpdate(CallableStatement callableStatement)
			throws SQLException {
		SQLContext.push(prepareSql(callableStatement, this.getSql()));
		return callableStatement.executeUpdate();
	}

	public int executeUpdate(CallableStatement callableStatement, String sql)
			throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.executeUpdate(sql);
	}

	public int executeUpdate(CallableStatement callableStatement, String sql,
			int autoGeneratedKeys) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.executeUpdate(sql, autoGeneratedKeys);
	}

	public int executeUpdate(CallableStatement callableStatement, String sql,
			int[] columnIndexes) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.executeUpdate(sql, columnIndexes);
	}

	public int executeUpdate(CallableStatement callableStatement, String sql,
			String[] columnNames) throws SQLException {
		SQLContext.push(prepareSql(callableStatement, sql));
		return callableStatement.executeUpdate(sql, columnNames);
	}

	public int[] executeBatch(CallableStatement callableStatement)
			throws SQLException {
		//@TODO
		return callableStatement.executeBatch();
	}
	public String getSql() {
		return this.sql;
	}

	public void setSql(String sql) {
		this.sql = sql;
	}


}
